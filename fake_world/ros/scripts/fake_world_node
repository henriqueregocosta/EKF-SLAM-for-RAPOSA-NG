#!/usr/bin/env python

import fake_world_ros.fake_world_node
import rospy
import math
import numpy as np
import tf
import matplotlib.pyplot as plt

from geometry_msgs.msg import PoseStamped
from nav_msgs.msg import Odometry
from visualization_msgs.msg import MarkerArray
from visualization_msgs.msg import Marker

class fake_world(object):

    def __init__(self):
        # register node in ROS network
        rospy.init_node('fake_world', anonymous=False)
        # print message in terminal
        rospy.loginfo('fake_world online')


    def run_sim(self, world_type, robot):
        # world creation
        self.landmarks, self.trajectory = createworld(world_type)

        # for the plot, adjust accordingly to world_type
        plt.xlim((-10,10))
        plt.ylim((-10,10))

        rate = rospy.Rate(50) # T=0.01s

        # not rospy.is_shutdown() and :
        xx=[]
        yy=[]
        for j,robot.pose in enumerate(self.trajectory):
            if not rospy.is_shutdown():
                # robot.pose = self.trajectory[j-1]
                robot.compute_movement(self.trajectory, j)
                # every x movements, provide observation
                if j%4 == 0:
                    robot.now = rospy.Time.now()
                    robot.compute_observation(self.landmarks, j)
                
                # plotting the poses
                # plt.plot(robot.pose[0], robot.pose[1], 'b*')

                # # update plot
                # plt.draw()
                # pause = 1/200000000000
                # plt.pause(pause)

                rate.sleep()

        # plot

        for i in range(0, len(self.trajectory)):
            xx.append(self.trajectory[i][0])
            yy.append(self.trajectory[i][1])
        for i in range(0, len(self.landmarks)):
            plt.plot(self.landmarks[i][0], self.landmarks[i][1], 'r+')

        plt.plot(xx, yy, '-b')    
        plt.title('Synthetic data')
        plt.show()    

class robot(object):
    # ----------------
    # all robot related stuff are here
    # ----------------

    def __init__(self):
        self.pose=[0, 0, 0]
        # setup publishers
        self.posePublisher = rospy.Publisher('fake_pose', PoseStamped, queue_size=100000)
        self.obsPublisher = rospy.Publisher('fake_obs',MarkerArray,queue_size=100000)
        self.odomPublisher = rospy.Publisher('fake_odom',Odometry,queue_size=100000)
        self.now = rospy.Time.now()

    def compute_observation(self, landmarks, j):
        # ------------------------------
        # given landmark world coordinates,
        # computes the true pose of the landmark in
        # the robot (camera) frame of reference
        # also decides which landmarks are in the
        # robots field of view
        # ------------------------------

        observation=[]

        for i in range(len(landmarks)):

            x_lm=landmarks[i][0]
            y_lm=landmarks[i][1]

            x_r=self.pose[0]
            y_r=self.pose[1]
            theta_r=self.pose[2]

            z = np.zeros(3)

            z[0] = (x_lm - x_r)*math.cos(theta_r) + (y_lm - y_r)*math.sin(theta_r)
            z[1] = -(x_lm - x_r)*math.sin(theta_r) + (y_lm - y_r)*math.cos(theta_r)
            z[2] = landmarks[i][2]

            if self.is_in_line_of_sight(z):
                observation.append(z)

        # plotting the landmarks
        # for i in range(len(landmarks)):
        #     for k in range(len(observation)):
        #         if landmarks[i][2]==observation[k][2]:
        #             plt.plot(landmarks[i][0], landmarks[i][1], 'r+')

        self.translate_obs(observation, j)

    def is_in_line_of_sight(self, z):
        # -----------------------
        # check if camera measurement is in line of sight
        # -----------------------

        # FOV equal to 140 deg
        FOV=140*math.pi/180

        x = z[0]
        y = z[1]

        dist = math.sqrt(x**2+y**2)

        if x <= 0 or dist > 4:
            return False

        obs_angle = math.atan2(y, x)

        if obs_angle > -FOV/2 and obs_angle < FOV/2:
            return True
        else:
            return False
    
    def translate_obs(self, obs, j):
        # ------------------------------
        # translate obs vector into marker array
        # message
        # -----------------------

        # creates empty MarkerArray message
        markerArray=MarkerArray()

        robot.now = rospy.Time.now()

        for i in range(len(obs)):

            marker=Marker()

            # header
            marker.header.frame_id = "/base_link"
            marker.type = marker.SPHERE
            marker.header.stamp.nsecs = self.now.nsecs
            marker.header.stamp.secs = self.now.secs
            # observation
            marker.pose.position.x = obs[i][0]
            marker.pose.position.y = obs[i][1]
            marker.id = obs[i][2]

            marker.pose.position.z = j # for debugging

            markerArray.markers.append(marker)

        # publishes markerArray    
        self.obsPublisher.publish(markerArray)

    def compute_movement(self, trajectory, j):
        # ------------------------
        # given the trajectory and the current iteration
        # computes the movement vector
        # ------------------------
        if j>0:
            movement = np.zeros(3)
            movement[0] = trajectory[j][0]
            movement[1] = trajectory[j][1]
            movement[2] = trajectory[j][2]

            self.translate_odom(movement,j)

    def translate_odom(self, movement,i):
        # --------------------------------------
        # translates movement info into odom message
        # --------------------------------------
        # creates empty pose message
        odom_msg=Odometry()

        robot.now = rospy.Time.now()

        # header
        odom_msg.header.stamp.nsecs = self.now.nsecs
        odom_msg.header.stamp.secs = self.now.secs

        # odom
        odom_msg.pose.pose.position.x = movement[0]
        odom_msg.pose.pose.position.y = movement[1]
        quaternion = tf.transformations.quaternion_from_euler(0, 0, movement[2])
        odom_msg.pose.pose.orientation.x = quaternion[0]
        odom_msg.pose.pose.orientation.y = quaternion[1]
        odom_msg.pose.pose.orientation.z = quaternion[2]
        odom_msg.pose.pose.orientation.w = quaternion[3]

        # debugging
        odom_msg.pose.pose.position.z = i

        # publishes odometry message
        self.odomPublisher.publish(odom_msg)

def createworld(worldtype):

    trajectory = []
    landmarks = []

    if worldtype=='world1':
        trajectory = straightline(0,0,0,0.5,10,'x')
        landmarks = finite_wall(0, 1, 10, 1, 1, 'x')
    elif worldtype == 'world2':
        trajectory = straightline(0,0,0,0.5,12,'x')
        trajectory.extend(straightline(6, -0.5, -math.pi/2, -0.5, 8, 'y'))
        trajectory.extend(straightline(6, -5, math.pi, -0.5, 12, 'x'))
        trajectory.extend(straightline(0, -5, math.pi/2, 0.5, 9, 'y'))
        landmarks = finite_wall(-1, 1, 0, 8, 1, 'x')
        landmarks.extend(finite_wall(1, -1, 30, 4, 1, 'x'))
        landmarks.extend(finite_wall(1, -4, 50, 4, 1, 'x'))
        landmarks.extend(finite_wall(-1, -6, 70, 8, 1, 'x'))
        landmarks.extend(finite_wall(7, 0, 90, 6, -1, 'y'))
        landmarks.extend(finite_wall(-1, 0, 110, 6, -1, 'y'))
        landmarks.extend(finite_wall(1, -2, 130, 2, -1, 'y'))
        landmarks.extend(finite_wall(5, -2, 140, 2, -1, 'y'))

    elif worldtype == 'world3':
        trajectory = straightline(0,0,0,0.5,5,'x')
        trajectory.extend(straightline(3, 0, math.pi/4, 0.5, 5, 'angle'))
        trajectory.extend(straightline(5, 2, math.pi/2, 0.5, 5, 'y'))
        trajectory.extend(straightline(5, 4.5, 3*math.pi/4, 0.5, 5, 'angle'))
        trajectory.extend(straightline(3, 6, -3*math.pi/4, 0.5, 5, 'angle'))
        trajectory.extend(straightline(1, 4, 9*math.pi/10, 0.5, 5, 'angle'))
        landmarks = finite_wall(0, 7, 0, 1, 1, 'x')
        landmarks.extend(finite_wall(2.5, 2.5, 5, 0, 1, 'x'))
        landmarks.extend(finite_wall(-2, 3, 10, 0, 1, 'x'))
        landmarks.extend(finite_wall(3, -2, 15, 1, 1, 'x'))

    elif worldtype == 'world4':
        trajectory = straightline(0,0,0,0.1,12*5,'x')
        trajectory.extend(straightline(6, -0.5, -math.pi/2, -0.1, 8*5, 'y'))
        trajectory.extend(straightline(6, -5, math.pi, -0.1, 12*5, 'x'))
        trajectory.extend(straightline(0, -5, math.pi/2, 0.1, 9*5, 'y'))
        landmarks = finite_wall(-1, 1, 0, 2, 4, 'x')
        landmarks.extend(finite_wall(1, -1, 30, 1, 4, 'x'))
        landmarks.extend(finite_wall(1, -4, 50, 1, 4, 'x'))
        landmarks.extend(finite_wall(-1, -6, 70, 2, 4, 'x'))
        landmarks.extend(finite_wall(7, 0, 90, 2, -3, 'y'))
        landmarks.extend(finite_wall(-1, 0, 110, 2, -3, 'y'))
        landmarks.extend(finite_wall(1, -2, 130, 2, -1, 'y'))
        landmarks.extend(finite_wall(5, -2, 140, 2, -1, 'y'))




    return landmarks, trajectory

def finite_wall(x, y, first_id, n, step, direction):
    # ---------------
    # x, y, first wall point
    # n number of points
    # ---------------

    if direction=='x':
        inc_x=1
        inc_y=0
    else:
        inc_x=0
        inc_y=1

    wall=[[x, y, first_id]]

    i=0
    while i<n:
        x=x+inc_x*step
        y=y+inc_y*step
        identif=i+first_id+1;
        wall.append([x, y, identif])
        i+=1

    return wall

def straightline(x, y, theta, step, n, direction):
    # -------------
    # x, y, theta first points
    # -------------

    # if direction is 1 direction is y, 0 otherwise
    if direction=='x':
        inc_x=1
        inc_y=0
    elif direction == 'y':
        inc_x=0
        inc_y=1
    elif direction == 'angle':
        inc_x=math.cos(theta)
        inc_y=math.sin(theta)


    trajectory=[[0, 0, 0]]
    trajectory[0][0] = x
    trajectory[0][1] = y
    trajectory[0][2] = theta

    for i in range(n):
        point=[0, 0, 0]
        point[0]=trajectory[i][0]+inc_x*step
        point[1]=trajectory[i][1]+inc_y*step
        point[2]=trajectory[i][2]
        trajectory.append(point)

    return trajectory

def main():
    fake_world1=fake_world()
    robot1=robot()
    fake_world1.run_sim('world4', robot1)

if __name__ == '__main__':
    main()
