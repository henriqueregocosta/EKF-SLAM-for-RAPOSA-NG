#!/usr/bin/env python

import fake_world_ros.fake_world_node
import rospy
import math
import tf
import numpy

from geometry_msgs.msg import PoseStamped
from nav_msgs.msg import Odometry
from visualization_msgs.msg import MarkerArray
from visualization_msgs.msg import Marker

class fake_world(object):
    # ----------------------------------
    # Receives an array of odometry and
    # landmark data and computes the 
    # data to be received by the robot
    # also receives the type of world and 
    # trajectory
    # ----------------------------------
    def __init__(self):
        # register node in ROS network
        rospy.init_node('fake_world', anonymous=False)
        # print message in terminal
        rospy.loginfo('fake_world node is online')
        # setup publishers
        self.obsPublisher = rospy.Publisher('fake_obs',MarkerArray,queue_size=10)
        self.odomPublisher = rospy.Publisher('fake_odom',Odometry,queue_size=10)
        self.posePublisher = rospy.Publisher('fake_pose', PoseStamped, queue_size=10)
        self.tf_br = tf.TransformBroadcaster()

    def run_sim(self, world_type, movement_type, ObsTranslator):
        # world creation
        if world_type=='wall':
            landmark_list=self.finite_wall(1, 0, 10)
        if movement_type=='straightline':
            trajectory=self.straightline(3, 0, 0.1, 20)
        rpose=robot_pose()
        rpose.x=trajectory[0].x
        rpose.y=trajectory[0].y
        # pose.theta= TODO

        j=0 # will be useful for something
        rate = rospy.Rate(2) # 0.5 Hz
        while not rospy.is_shutdown():
            self.tf_br.sendTransform((0, 0, 0),
                                    tf.transformations.quaternion_from_euler(0, 0, 0),
                                    rospy.Time.now(),
                                    '/base_link',
                                    "map")
            movement=self.compute_movement(rpose, trajectory, j)
            rpose=self.compute_pose(rpose, trajectory, j)
            observation=self.compute_observation(landmark_list, rpose)
            odom_msg=self.translate_odom(movement)
            pose_msg=self.translate_pose(rpose)
            obs_msg=self.translate_obs(observation)
            self.odomPublisher.publish(odom_msg)
            self.posePublisher.publish(pose_msg)
            self.obsPublisher.publish(obs_msg)

            rospy.loginfo('markers I see:')
            rospy.loginfo(str(ObsTranslator.markersisee))

            j+=1
            if j==len(trajectory)-1:
                break
            rate.sleep()

    def compute_pose(self, rpose, trajectory, i):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        pose=robot_pose()
        pose.x=trajectory[i].x
        pose.y=trajectory[i].y

        return pose

    def translate_pose(self, rpose):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        pose_msg=PoseStamped()
        pose_msg.header.frame_id = "/base_link"
        pose_msg.pose.position.x = rpose.x
        pose_msg.pose.position.y = rpose.y
        pose_msg.pose.orientation = tf.transformations.quaternion_from_euler(0, 0, rpose.theta)

        return pose_msg

    def compute_movement(self, rpose, trajectory, i):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        movement=robot_pose()
        movement.x=trajectory[i+1].x-trajectory[i].x
        movement.y=trajectory[i+1].y-trajectory[i].y

        return movement

    def translate_odom(self, movement):
        # --------------------------------------
        # translates movement info into odom message
        # --------------------------------------
        # creates empty pose message
        odom_msg=Odometry()
        odom_msg.pose.pose.position.x = movement.x
        odom_msg.pose.pose.position.y = movement.y
        # orientation
        # missing: quaternion to euler angle transformation
        # publish odom message
        return odom_msg

    def compute_observation(self, landmark_list, rpose):
        # ------------------------------
        # given landmark world coordinates,
        # computes the true pose of the landmark in
        # the robot frame of reference
        # also decides which landmarks are in the
        # robots field of view -> IMPLEMENT
        # ------------------------------
        n=len(landmark_list)
        observation=[]

        for i in range(n):
            # compute x and y of landmark
            # compute x and y of robot
            camera_measurement=landmark(0,0,0)
            x_lm=landmark_list[i].x
            y_lm=landmark_list[i].y
            x_r=rpose.x
            y_r=rpose.y
            theta_r=90*math.pi/180 # just for now, robot is looking "up"

            camera_measurement.x=(x_lm - x_r)*math.sin(theta_r) - (y_lm - y_r)*math.cos(theta_r)
            camera_measurement.y=-(x_lm - x_r)*math.cos(theta_r) + (y_lm - y_r)*math.sin(theta_r)
            camera_measurement.id=landmark_list[i].id

            if self.is_in_line_of_sight(rpose, camera_measurement):
                observation.append(camera_measurement)

        return observation

    def is_in_line_of_sight(self, rpose, camera_measurement):
        FOV=120*math.pi/180
        x=camera_measurement.x
        y=camera_measurement.y
        theta=90*math.pi/180 # just for now, robot is looking up
        dist=math.sqrt(x**2+y**2)
        dydx=abs(y/x)
        fov_tangent=abs(math.tan(theta-FOV/2))# tangent of the field of view

        if dydx >= fov_tangent and y>0 and dist<4:
            return True
        else:
            return False
    
    def translate_obs(self, obs):
        # ------------------------------
        # translate obs vector into marker array
        # message
        # -----------------------

        # creates empty MarkerArray message
        n=len(obs)
        markerArray=MarkerArray()
        for i in range(n):
            marker=Marker()
            marker.header.frame_id = "/base_link"
            marker.type = marker.SPHERE
            marker.scale.x = 0.5
            marker.scale.y = 0.5
            marker.scale.z = 0.5
            marker.color.a = 1.0
            marker.color.r = 1.0+i
            marker.color.g = 1.0
            marker.color.b = 0.0
            marker.pose.position.x = obs[i].x
            marker.pose.position.y = obs[i].y
            marker.id = obs[i].id
            markerArray.markers.append(marker)

        #rospy.loginfo('markerArray com 2')
        #rospy.loginfo(str(markerArray))
        # rospy.loginfo(str(markerArray))
        # preturn marker array message
        return markerArray

    def finite_wall(self, x, y, n):
        # ---------------
        # generates and infite wall of landmarks
        # adds a new landmark with the same x-coordinate
        # of the last one but one unit ahead in the
        # y-axis
        # ---------------
        wall=[landmark(x,y,0)]
        i=0
        while i<n:
            x=x
            y=y+1;
            identif=i+1;
            new_landmark=landmark(x,y,identif)
            wall.append(new_landmark)
            i+=1
        return wall

    def straightline(self, x, y, step, n):
        # -------------
        # generates a list of points that corresponds
        # to a straight line trajectory with an assign step
        # -------------
        identif=0
        trajectory=[landmark(x,y,identif)]
        for i in range(0, n):
            coordinate=landmark(trajectory[i].x, trajectory[i].y+step, i+1)
            trajectory.append(coordinate)
        return trajectory

class landmark(object):
    # -------------
    # creates a list of landmarks and their world 
    # todo: translate into code the observation model
    # this needs to be integrated with the algorihm node
    # -------------
    def __init__(self, x, y, identif):
        self.x=x
        self.y=y
        self.id=identif

class robot_pose(object):
    # ----------------
    # represents the current pose of the robot
    # ----------------
    def __init__(self):
        self.x=0
        self.y=0
        self.theta=90*math.pi/180 # for now, robot is looking up


class ObsInterp(object):

    def __init__(self):
        '''
        Class constructor: will get executed at the moment
        of object creation
        '''

        rospy.loginfo('Observations Interperter Started')
        # subscribe to RaposaNG ARUCO topic
        rospy.Subscriber("fake_obs", MarkerArray, self.ARUCOCallback)
        # define member variable and initialize with a big value
        # it will store the distance from the robot to the walls
        self.markersisee = [None, None, None]

    
    def ARUCOCallback(self, msg):
        '''
        This function gets executed everytime a ARUCO Marker msg is received on the
        topic: /fake_obs
        '''
        observed_features = [None, None, None]
        N = len(msg.markers)

        for i in range(N):
            ox = msg.markers[i].pose.position.x
            oy = msg.markers[i].pose.position.y
            oid = msg.markers[i].id
            update = [ox, oy, oid]

            if observed_features == [None, None, None]: #if it is the first marker ever observed
                observed_features = update       #the vector is the first marker
            else:
                observed_features.append(update) #the marker is added to the vector

        self.markersisee = observed_features
        #rospy.loginfo('Observed features:')
        #rospy.loginfo(str(observed_features))


def main():
    fake_world1=fake_world()
    ObsTranslator = ObsInterp()
    fake_world1.run_sim('wall', 'straightline', ObsTranslator)

if __name__ == '__main__':
    main()
