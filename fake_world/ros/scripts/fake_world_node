#!/usr/bin/env python

import fake_world_ros.fake_world_node
import rospy
import math
import tf
import numpy
import plotresults
import matplotlib.pyplot as plt

from geometry_msgs.msg import PoseStamped
from nav_msgs.msg import Odometry
from visualization_msgs.msg import MarkerArray
from visualization_msgs.msg import Marker

class fake_world(object):
    # ----------------------------------
    # Receives an array of odometry and
    # landmark data and computes the 
    # data to be received by the robot
    # also receives the type of world and 
    # trajectory
    # ----------------------------------
    def __init__(self):
        # register node in ROS network
        rospy.init_node('fake_world', anonymous=False)
        # print message in terminal
        rospy.loginfo('fake_world node is online')

    def run_sim(self, world_type, robot):
        # world creation
        self.landmark_list, self.trajectory = createworld(world_type)
        # first_pose=robot_pose()
        # first_pose.x=0
        # first_pose.y=0
        # first_pose.theta=0
        # self.trajectory.insert(0,first_pose)

        j=0 # will be useful for something
        first=1
        rate = rospy.Rate(1000) # T=0.01s

        # plot
        plt.ylim((-1,9))
        plt.xlim((-1,9))

        while not rospy.is_shutdown() and j<len(self.trajectory)-1:
            robot.send_tf()
            robot.compute_pose(self.trajectory, j)
            robot.compute_observation(self.landmark_list, first)
            robot.compute_movement(self.trajectory, j, first)
            
            plt.plot(robot.pose.x, robot.pose.y, 'b*')
            for i in range(len(self.landmark_list)):
                for k in range(len(robot.observation)):
                    if self.landmark_list[i].id==robot.observation[k].id:
                        plt.plot(self.landmark_list[i].x, self.landmark_list[i].y, 'r^')

            plt.draw()
            plt.pause(0.00000000001)

            if first == 1:
                first = 0
                j=-1

            j+=1
            rate.sleep()

        plt.show()    

        # plotresults.plot_world(self.landmark_list, self.trajectory, robot.observation, world_type)

class robot(object):
    # ----------------
    # all robot related stuff are here
    # ----------------

    def __init__(self):
        self.pose=robot_pose()
        # setup publishers
        self.posePublisher = rospy.Publisher('fake_pose', PoseStamped, queue_size=10)
        self.obsPublisher = rospy.Publisher('fake_obs',MarkerArray,queue_size=10)
        self.odomPublisher = rospy.Publisher('fake_odom',Odometry,queue_size=10)

        # tf stuff
        self.tf_br = tf.TransformBroadcaster()

    def compute_pose(self, trajectory, i):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        self.pose.x=trajectory[i].x
        self.pose.y=trajectory[i].y
        self.pose.theta=trajectory[i].theta

        # rospy.loginfo('Pose')
        # rospy.loginfo(str([self.pose.x, self.pose.y, self.pose.theta, i]))

        self.translate_pose()

    def translate_pose(self):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        pose_msg=PoseStamped()
        pose_msg.header.frame_id = "/base_link"
        pose_msg.pose.position.x = self.pose.x
        pose_msg.pose.position.y = self.pose.y
        quat = tf.transformations.quaternion_from_euler(0, 0, self.pose.theta)
        pose_msg.pose.orientation.x = quat[0]
        pose_msg.pose.orientation.y = quat[1] 
        pose_msg.pose.orientation.z = quat[2] 
        pose_msg.pose.orientation.w = quat[3] 

        # publishes the pose
        self.posePublisher.publish(pose_msg)

    def compute_observation(self, landmark_list, first):
        # ------------------------------
        # given landmark world coordinates,
        # computes the true pose of the landmark in
        # the robot (camera) frame of reference
        # also decides which landmarks are in the
        # robots field of view
        # ------------------------------
        n=len(landmark_list)
        self.observation=[]

        for i in range(n):
            # compute x and y of landmark
            # compute x and y of robot
            camera_measurement=landmark(0,0,0)
            x_lm=landmark_list[i].x
            y_lm=landmark_list[i].y
            x_r=self.pose.x
            y_r=self.pose.y
            theta_r=self.pose.theta

            camera_measurement.x=(x_lm - x_r)*math.cos(theta_r) + (y_lm - y_r)*math.sin(theta_r)
            camera_measurement.y=-(x_lm - x_r)*math.sin(theta_r) + (y_lm - y_r)*math.cos(theta_r)
            camera_measurement.id=landmark_list[i].id

            # print('camera_measurement before los')
            # print(([camera_measurement.x, camera_measurement.y, camera_measurement.id]))

            if self.is_in_line_of_sight(camera_measurement):
                self.observation.append(camera_measurement)
                # debug
                # rospy.loginfo('Observations')
                # rospy.loginfo(str([camera_measurement.x, camera_measurement.y, camera_measurement.id]))

            #if first == 1:
                # observation=[]

        self.translate_obs(self.observation)

    def is_in_line_of_sight(self, camera_measurement):
        # -----------------------
        # check if camera measurement is in line of sight
        # -----------------------

        FOV=140*math.pi/180
        x=camera_measurement.x
        y=camera_measurement.y
        theta=self.pose.theta
        dist=math.sqrt(x**2+y**2)
        # if y != 0:
        #     dxdy=abs(x/y)
        # else:
        #     dydx=-1

        # fov_tangent=abs(math.tan(theta-FOV/2))# tangent of the field of view

        # if dxdy >= fov_tangent and x>0 and dist<4:
        if y != 0:
            obs_angle = math.atan(x/y)
        else:
            obs_angle = FOV/2+1

        if obs_angle > -FOV/2 and obs_angle < FOV/2 and x > 0 and dist < 4:
             return True
        else:
            return False
    
    def translate_obs(self, obs):
        # ------------------------------
        # translate obs vector into marker array
        # message
        # -----------------------

        # creates empty MarkerArray message
        n=len(obs)
        markerArray=MarkerArray()
        for i in range(n):
            marker=Marker()
            marker.header.frame_id = "/base_link"
            marker.type = marker.SPHERE
            marker.scale.x = 0.5
            marker.scale.y = 0.5
            marker.scale.z = 0.5
            marker.color.a = 1.0
            marker.color.r = 1.0+i
            marker.color.g = 1.0
            marker.color.b = 0.0
            marker.pose.position.x = obs[i].x
            marker.pose.position.y = obs[i].y
            marker.id = obs[i].id
            markerArray.markers.append(marker)

        # publishes markerArray    
        self.obsPublisher.publish(markerArray)

    def compute_movement(self, trajectory, i, first):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        movement=robot_pose()
        movement.x=trajectory[i+1].x-trajectory[i].x
        movement.y=trajectory[i+1].y-trajectory[i].y
        movement.theta=trajectory[i+1].theta-trajectory[i].theta

        if first==1:
            movement.x=0
            movement.y=0
            movement.theta=0

        self.translate_odom(movement)

    def translate_odom(self, movement):
        # --------------------------------------
        # translates movement info into odom message
        # --------------------------------------
        # creates empty pose message
        odom_msg=Odometry()
        odom_msg.pose.pose.position.x = movement.x
        odom_msg.pose.pose.position.y = movement.y
        quaternion = tf.transformations.quaternion_from_euler(0, 0, movement.theta)
        odom_msg.pose.pose.orientation.x = quaternion[0]
        odom_msg.pose.pose.orientation.y = quaternion[1]
        odom_msg.pose.pose.orientation.z = quaternion[2]
        odom_msg.pose.pose.orientation.w = quaternion[3]

        # publishes odometry message
        self.odomPublisher.publish(odom_msg)

    def send_tf(self):
        self.tf_br.sendTransform((0, 0, 0),
                                    tf.transformations.quaternion_from_euler(0, 0, 0),
                                    rospy.Time.now(),
                                    '/base_link',
                                    "map")

class landmark(object):
    # -------------
    # creates a list of landmarks and their world 
    # todo: translate into code the observation model
    # this needs to be integrated with the algorihm node
    # -------------
    def __init__(self, x, y, identif):
        self.x=x
        self.y=y
        self.id=identif

class robot_pose(object):
    # ----------------
    # represents the current pose of the robot
    # ----------------
    def __init__(self):
        self.x=0
        self.y=0
        self.theta=0 # for now, robot is looking up

def createworld(worldtype):
    if worldtype=='world1':
        landmark_list=finite_wall(1, 0, 10, 1, 'y')
        trajectory=straightline(3, 0, 90*math.pi/180, 0.1, 100,'y')

    if worldtype=='world2':
        landmark_list=world2_lm()
        trajectory=world2_tr()

    if worldtype=='world3':
        landmark_list=world3_lm()
        trajectory=world3_tr()

    if worldtype=='world4':
        trajectory=straightline(0,0,90*math.pi/180,0.5,20,'y')
        landmark_list=finite_wall(1, 0, 10, 1, 'y')

    if worldtype=='world5':
        trajectory=straightline(0,0,0,0.5,20,'x')
        landmark_list=finite_wall(0, 1, 10, 1, 'x')

    if worldtype=='world6':
        trajectory = straightline(0,0,0,0.01,250,'x')
        landmark_list = finite_wall(0, 1, 10, 1, 'x')


    return landmark_list, trajectory

def finite_wall(x, y, n, step, direction):
    # ---------------
    # generates and infite wall of landmarks
    # adds a new landmark with the same x-coordinate
    # of the last one but one unit ahead in the
    # y-axis
    # ---------------

    if direction=='x':
        inc_x=1
        inc_y=0
    else:
        inc_x=0
        inc_y=1

    wall=[landmark(x,y,0)]
    i=0
    while i<n:
        x=x+inc_x*step
        y=y+inc_y*step
        identif=i+1;
        new_landmark=landmark(x,y,identif)
        wall.append(new_landmark)
        i+=1
    return wall

def straightline(x, y, theta, step, n, direction):
    # -------------
    # generates a list of points that corresponds
    # to a straight line trajectory with an assigned step
    # and robot looking up (theta=90deg)
    # -------------
    # if direction is 1 direction is y, 0 otherwise
    if direction=='x':
        inc_x=1
        inc_y=0
    else:
        inc_x=0
        inc_y=1

    trajectory=[robot_pose()]
    trajectory[0].x=x
    trajectory[0].y=y
    trajectory[0].theta=theta
    for i in range(n):
        point=robot_pose()
        point.x=trajectory[i].x+inc_x*step
        point.y=trajectory[i].y+inc_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    return trajectory

def world2_lm():
    landmarks=[]
    # 0
    landmark1=landmark(-4,0,0)
    landmarks.append(landmark1)
    # 1
    landmark1=landmark(-2,2,1)
    landmarks.append(landmark1)
    # 2
    landmark1=landmark(0,3,2)
    landmarks.append(landmark1)
    # 3
    landmark1=landmark(2,2,3)
    landmarks.append(landmark1)
    # 4
    landmark1=landmark(4,0,4)
    landmarks.append(landmark1)
    # 5
    landmark1=landmark(2,-2,5)
    landmarks.append(landmark1)
    # 6
    landmark1=landmark(0,-3,6)
    landmarks.append(landmark1)
    # 7
    landmark1=landmark(-2,-2,7)
    landmarks.append(landmark1)
    return landmarks

def world2_tr():
    # -------------
    # generates a list of points that corresponds
    # to a straight line trajectory with an assigned step
    # and robot looking up (theta=90deg)
    # -------------
    trajectory=[robot_pose()]
    # from (-1,-1) to (-1,1)
    x=-1
    y=-1
    theta=90*math.pi/180
    identif=0
    step=0.1
    walkin_x=0
    walkin_y=1
    n=19
    trajectory[identif].x=x
    trajectory[identif].y=y
    trajectory[identif].theta=theta
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    # from (-1,1) to (1,1)
    x=-1
    y=1
    theta=0
    identif=20
    step=0.1
    walkin_x=1
    walkin_y=0
    n=19
    point=robot_pose()
    point.x=x
    point.y=y
    point.theta=theta
    trajectory.append(point)
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    # from (1,1) to (1,-1)
    x=1
    y=1
    theta=270*math.pi/180
    identif=40
    step=0.1
    walkin_x=0
    walkin_y=-1
    n=19
    point=robot_pose()
    point.x=x
    point.y=y
    point.theta=theta
    trajectory.append(point)
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    # from (1,-1) to (-1,-1)
    x=1
    y=-1
    theta=180*math.pi/180
    identif=60
    step=0.1
    walkin_x=-1
    walkin_y=0
    n=19
    point=robot_pose()
    point.x=x
    point.y=y
    point.theta=theta
    trajectory.append(point)
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    return trajectory

def world3_lm():
    landmarks=[]
    # 0
    landmark1=landmark(-4,0,0)
    landmarks.append(landmark1)
    # 1
    landmark1=landmark(-2,2,1)
    landmarks.append(landmark1)
    # 2
    landmark1=landmark(0,3,2)
    landmarks.append(landmark1)
    # 3
    landmark1=landmark(2,2,3)
    landmarks.append(landmark1)
    # 4
    landmark1=landmark(4,0,4)
    landmarks.append(landmark1)
    # 5
    landmark1=landmark(2,-2,5)
    landmarks.append(landmark1)
    # 6
    landmark1=landmark(0,-3,6)
    landmarks.append(landmark1)
    # 7
    landmark1=landmark(-2,-2,7)
    landmarks.append(landmark1)
    return landmarks

def world3_tr():
    # -------------
    # generates a list of points that corresponds
    # to a straight line trajectory with an assigned step
    # and robot looking up (theta=90deg)
    # -------------
    trajectory=[robot_pose()]
    # from (-3,-3) to (-1,1)
    x=-3
    y=-3
    theta=90*math.pi/180
    identif=0
    step=0.1
    walkin_x=0
    walkin_y=1
    n=39
    trajectory[identif].x=x
    trajectory[identif].y=y
    trajectory[identif].theta=theta
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    # from (-3,1) to (1,1)
    x=-3
    y=1
    theta=0
    identif=40
    step=0.1
    walkin_x=1
    walkin_y=0
    n=39
    point=robot_pose()
    point.x=x
    point.y=y
    point.theta=theta
    trajectory.append(point)
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    # from (1,1) to (1,-1)
    x=1
    y=1
    theta=270*math.pi/180
    identif=80
    step=0.1
    walkin_x=0
    walkin_y=-1
    n=19
    point=robot_pose()
    point.x=x
    point.y=y
    point.theta=theta
    trajectory.append(point)
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    # from (1,-1) to (-1,-1)
    x=1
    y=-1
    theta=180*math.pi/180
    identif=100
    step=0.1
    walkin_x=-1
    walkin_y=0
    n=19
    point=robot_pose()
    point.x=x
    point.y=y
    point.theta=theta
    trajectory.append(point)
    for i in range(identif, identif + n):
        point=robot_pose()
        point.x=trajectory[i].x+walkin_x*step
        point.y=trajectory[i].y+walkin_y*step
        point.theta=trajectory[i].theta
        trajectory.append(point)

    return trajectory

def main():
    fake_world1=fake_world()
    robot1=robot()
    fake_world1.run_sim('world6', robot1)

if __name__ == '__main__':
    main()
