#!/usr/bin/env python

import fake_world_ros.fake_world_node
import rospy

from geometry_msgs.msg import Pose
from nav_msgs.msg import Odometry
from visualization_msgs.msg import MarkerArray
from visualization_msgs.msg import Marker

class fake_world(object):
    # ----------------------------------
    # Receives an array of odometry and
    # landmark data and computes the 
    # data to be received by the robot
    # also receives the type of world and 
    # trajectory
    # ----------------------------------
    def __init__(self):
        # register node in ROS network
        rospy.init_node('fake_world', anonymous=False)
        # print message in terminal
        rospy.loginfo('fake_world node is online')
        # setup publishers
        self.obsPublisher = rospy.Publisher('fake_obs',MarkerArray,queue_size=10)
        self.odomPublisher = rospy.Publisher('fake_odom',Odometry,queue_size=10)
        self.posePublisher = rospy.Publisher('fake_pose', Pose, queue_size=10)

    def run_sim(self, world_type, movement_type, ObsTranslator):
        # world creation
        if world_type=='wall':
            landmark_list=self.finite_wall(1, 0, 10)
        if movement_type=='straightline':
            trajectory=self.straightline(3, 0, 0.2, 20)
        rpose=robot_pose()
        rpose.x=0
        rpose.y=0
        # pose.theta= TODO

        i=0 # will be useful for something
        rate = rospy.Rate(0.5) # 0.5 Hz
        while not rospy.is_shutdown():
            movement=self.compute_movement(rpose, trajectory, i)
            rpose=self.compute_pose(rpose, trajectory, i)
            observation=self.compute_observation(landmark_list,rpose)
            odom_msg=self.translate_odom(movement)
            pose_msg=self.translate_pose(rpose)
            obs_msg=self.translate_obs(observation)
            self.odomPublisher.publish(odom_msg)
            self.posePublisher.publish(pose_msg)
            self.obsPublisher.publish(obs_msg)
            rospy.loginfo('markers I see:')
            rospy.loginfo(str(ObsTranslator.markersisee))
            i+=1
            if i==len(trajectory):
                break
            rate.sleep()

    def compute_pose(self, rpose, trajectory, i):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        pose=robot_pose()
        pose.x=trajectory[i].x
        pose.y=trajectory[i].y

        return pose

    def translate_pose(self, rpose):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        pose_msg=Pose()
        pose_msg.position.x = rpose.x
        pose_msg.position.y = rpose.y

        return pose_msg

    def compute_movement(self, rpose, trajectory, i):
        # ------------------------
        # given the robot pose and the trajectory
        # computes the movement vector
        # ------------------------
        movement=robot_pose()
        movement.x=trajectory[i+1].x-trajectory[i].x
        movement.y=trajectory[i+1].y-trajectory[i].y

        return movement

    def translate_odom(self, movement):
        # --------------------------------------
        # translates movement info into odom message
        # --------------------------------------
        # creates empty pose message
        odom_msg=Odometry()
        odom_msg.pose.pose.position.x = movement.x
        odom_msg.pose.pose.position.y = movement.y
        # orientation
        # missing: quaternion to euler angle transformation
        # publish odom message
        return odom_msg

    def compute_observation(self, landmark_list, pose):
        # ------------------------------
        # given landmark world coordinates,
        # computes the true pose of the landmark in
        # the robot frame of reference
        # also decides which landmarks are in the
        # robots field of view -> IMPLEMENT
        # ------------------------------
        # creates empty MarkerArray message
        obs=[landmark(0,1,3)]
        obs.append(landmark(1,3,4))

        return obs
    
    def translate_obs(self, obs):
        # ------------------------------
        # translate obs vector into marker array
        # message
        # -----------------------

        # creates empty MarkerArray message
        marker=Marker()
        #rospy.loginfo(str(marker))
        markerArray=MarkerArray()
        #rospy.loginfo(str(markerArray))
        marker.pose.position.x = obs[0].x
        marker.pose.position.y = obs[0].y
        marker.id = obs[0].id
        markerArray.markers.append(marker)
        #rospy.loginfo(str(markerArray))
        marker=Marker()
        marker.pose.position.x = obs[1].x
        marker.pose.position.y = obs[1].y
        marker.id = obs[1].id
        markerArray.markers.append(marker)
        marker=Marker()
        marker.pose.position.x = 5
        marker.pose.position.y = 5
        marker.id = 5
        markerArray.markers.append(marker)
        #rospy.loginfo('markerArray com 2')
        #rospy.loginfo(str(markerArray))
        #rospy.loginfo(str(markerArray))
        # preturn marker array message
        return markerArray

    def finite_wall(self, x, y, n):
        # ---------------
        # generates and infite wall of landmarks
        # adds a new landmark with the same x-coordinate
        # of the last one but one unit ahead in the
        # y-axis
        # ---------------
        wall=[landmark(x,y,0)]
        i=0
        while i<n:
            x=x
            y=y+1;
            identif=i+1;
            new_landmark=landmark(x,y,identif)
            wall.append(new_landmark)
            i+=1
        return wall

    def straightline(self, x, y, step, n):
        # -------------
        # generates a list of points that corresponds
        # to a straight line trajectory with an assign step
        # -------------
        identif=0
        trajectory=[landmark(x,y,identif)]
        for i in range(0, n):
            coordinate=landmark(trajectory[i].x, trajectory[i].y+step, i+1)
            trajectory.append(coordinate)
        return trajectory

class landmark(object):
    # -------------
    # creates a list of landmarks and their world 
    # todo: translate into code the observation model
    # this needs to be integrated with the algorihm node
    # -------------
    def __init__(self, x, y, identif):
        self.x=x
        self.y=y
        self.id=identif

class robot_pose(object):
    # ----------------
    # represents the current pose of the robot
    # ----------------
    def __init__(self):
        self.x=0;
        self.y=0;
        self.theta=0;


class ObsInterp(object):

    def __init__(self):
        '''
        Class constructor: will get executed at the moment
        of object creation
        '''

        rospy.loginfo('Observations Interperter Started')
        # subscribe to RaposaNG ARUCO topic
        rospy.Subscriber("fake_obs", MarkerArray, self.ARUCOCallback)
        # define member variable and initialize with a big value
        # it will store the distance from the robot to the walls
        self.markersisee = [None, None, None]

    
    def ARUCOCallback(self, msg):
        '''
        This function gets executed everytime a ARUCO Marker msg is received on the
        topic: /fake_obs
        '''
        observed_features = [None, None, None]
        N = len(msg.markers)
        rospy.loginfo(str(N))

        for i in range(N):
            ox = msg.markers[i].pose.position.x
            oy = msg.markers[i].pose.position.y
            oid = msg.markers[i].id
            update = [ox, oy, oid]

            if observed_features == [None, None, None]: #if it is the first marker ever observed
                observed_features = update       #the vector is the first marker
            else:
                observed_features.append(update) #the marker is added to the vector

        self.markersisee = observed_features
        rospy.loginfo('Observed features:')
        rospy.loginfo(str(observed_features))


def main():
    fake_world1=fake_world()
    ObsTranslator = ObsInterp()
    fake_world1.run_sim('wall', 'straightline', ObsTranslator)

if __name__ == '__main__':
    main()
