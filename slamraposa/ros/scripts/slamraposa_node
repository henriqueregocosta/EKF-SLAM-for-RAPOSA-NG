#!/usr/bin/env python2.7

import matplotlib.pyplot as plt
import numpy as np
import Queue
import rospy
import thread


import EKF_SLAM
import observations_function as obs
import odometry_function as odo
import slamraposa_ros.slamraposa_node


def check_for_shutdown(queue, observations, odometry):
    while observations.subs.get_num_connections() and odometry.subs.get_num_connections():
        pass
    queue.put(['end'])


def update_noises(observations, odometry, Q, R):
    observations.Q = Q
    odometry.R = R

def main():
    rospy.init_node('slamraposa', anonymous=False)

    q = Queue.Queue()
    Q = np.identity(3)
    R = np.identity(3)

    operation = EKF_SLAM.SLAM(q)

    observations = obs.ObsInterp(q, Q)
    odometry = odo.OdoInterp(q, R)

    # to plot the results
    x=[]
    y=[]
    plt.ylim((-10,10))
    plt.xlim((-10,10))

    first = 1
    while not rospy.is_shutdown():

        if observations.subs.get_num_connections() and odometry.subs.get_num_connections():
            if first:
                thread.start_new_thread(check_for_shutdown, (q, observations, odometry))
                first = 0

            x.append(operation.mean_pred[0][0])
            y.append(operation.mean_pred[0][1])

            update_noises(observations, odometry, Q, R)

            event = q.get()     # event = ['obs', markers_I_see, Q]              
                                # or event = ['odo', position_and_quaternions, R]

            operation.EKF(event)
            q.task_done() 

        elif not first:
            break

    # plot
    for i in range(1, len(operation.mean_pred)):
                plt.plot(operation.mean_pred[i][0],operation.mean_pred[i][1], 'r+')
                
    plt.plot(x, y, '-b')
    plt.title('EKF-SLAM result')
    plt.show()

if __name__ == '__main__':
    main()